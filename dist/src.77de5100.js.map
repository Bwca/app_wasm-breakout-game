{"version":3,"sources":["../node_modules/assemblyscript/lib/loader/index.js","constants/wasm-url.constant.ts","models/canvas.model.ts","wasm-shared/enums/game-statuses.enum.ts","index.ts"],"names":[],"mappings":"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,CAAC,WAA3C,EAAwD,MAAM,CAAC,YAA/D,CAAf;AJVR,AIWQ,EAAA,qBAAqB,CAAC;AJV9B,AIU8B,WAAM,YAAY,CAAC,QAAb,EAAN;AJT9B,AIS8B,GAAD,CAArB;AJRR,AIUK,CATL;AJAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"src.77de5100.js","sourceRoot":"../src","sourcesContent":["\"use strict\";\n\n// Runtime header offsets\nconst ID_OFFSET = -8;\nconst SIZE_OFFSET = -4;\n\n// Runtime ids\nconst ARRAYBUFFER_ID = 0;\nconst STRING_ID = 1;\nconst ARRAYBUFFERVIEW_ID = 2;\n\n// Runtime type information\nconst ARRAYBUFFERVIEW = 1 << 0;\nconst ARRAY = 1 << 1;\nconst SET = 1 << 2;\nconst MAP = 1 << 3;\nconst VAL_ALIGN = 1 << 5;\nconst VAL_SIGNED = 1 << 10;\nconst VAL_FLOAT = 1 << 11;\nconst VAL_NULLABLE = 1 << 12;\nconst VAL_MANAGED = 1 << 13;\nconst KEY_ALIGN = 1 << 14;\nconst KEY_SIGNED = 1 << 19;\nconst KEY_FLOAT = 1 << 20;\nconst KEY_NULLABLE = 1 << 21;\nconst KEY_MANAGED = 1 << 22;\n\n// Array(BufferView) layout\nconst ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;\nconst ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;\nconst ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8;\nconst ARRAYBUFFERVIEW_SIZE = 12;\nconst ARRAY_LENGTH_OFFSET = 12;\nconst ARRAY_SIZE = 16;\n\nconst BIGINT = typeof BigUint64Array !== \"undefined\";\nconst THIS = Symbol();\nconst CHUNKSIZE = 1024;\n\n/** Gets a string from an U32 and an U16 view on a memory. */\nfunction getStringImpl(U32, U16, ref) {\n  var length = U32[(ref + SIZE_OFFSET) >>> 2] >>> 1;\n  var offset = ref >>> 1;\n  if (length <= CHUNKSIZE) return String.fromCharCode.apply(String, U16.subarray(offset, offset + length));\n  const parts = [];\n  do {\n    const last = U16[offset + CHUNKSIZE - 1];\n    const size = last >= 0xD800 && last < 0xDC00 ? CHUNKSIZE - 1 : CHUNKSIZE;\n    parts.push(String.fromCharCode.apply(String, U16.subarray(offset, offset += size)));\n    length -= size;\n  } while (length > CHUNKSIZE);\n  return parts.join(\"\") + String.fromCharCode.apply(String, U16.subarray(offset, offset + length));\n}\n\n/** Prepares the base module prior to instantiation. */\nfunction preInstantiate(imports) {\n  const baseModule = {};\n\n  function getString(memory, ref) {\n    if (!memory) return \"<yet unknown>\";\n    const buffer = memory.buffer;\n    return getStringImpl(new Uint32Array(buffer), new Uint16Array(buffer), ref);\n  }\n\n  // add common imports used by stdlib for convenience\n  const env = (imports.env = imports.env || {});\n  env.abort = env.abort || function abort(mesg, file, line, colm) {\n    const memory = baseModule.memory || env.memory; // prefer exported, otherwise try imported\n    throw Error(\"abort: \" + getString(memory, mesg) + \" at \" + getString(memory, file) + \":\" + line + \":\" + colm);\n  }\n  env.trace = env.trace || function trace(mesg, n) {\n    const memory = baseModule.memory || env.memory;\n    console.log(\"trace: \" + getString(memory, mesg) + (n ? \" \" : \"\") + Array.prototype.slice.call(arguments, 2, 2 + n).join(\", \"));\n  }\n  imports.Math = imports.Math || Math;\n  imports.Date = imports.Date || Date;\n\n  return baseModule;\n}\n\n/** Prepares the final module once instantiation is complete. */\nfunction postInstantiate(baseModule, instance) {\n  const rawExports = instance.exports;\n  const memory = rawExports.memory;\n  const table = rawExports.table;\n  const alloc = rawExports[\"__alloc\"];\n  const retain = rawExports[\"__retain\"];\n  const rttiBase = rawExports[\"__rtti_base\"] || ~0; // oob if not present\n\n  // Provide views for all sorts of basic values\n  var buffer, I8, U8, I16, U16, I32, U32, F32, F64, I64, U64;\n\n  /** Updates memory views if memory has grown meanwhile. */\n  function checkMem() {\n    // see: https://github.com/WebAssembly/design/issues/1210\n    if (buffer !== memory.buffer) {\n      buffer = memory.buffer;\n      I8  = new Int8Array(buffer);\n      U8  = new Uint8Array(buffer);\n      I16 = new Int16Array(buffer);\n      U16 = new Uint16Array(buffer);\n      I32 = new Int32Array(buffer);\n      U32 = new Uint32Array(buffer);\n      if (BIGINT) {\n        I64 = new BigInt64Array(buffer);\n        U64 = new BigUint64Array(buffer);\n      }\n      F32 = new Float32Array(buffer);\n      F64 = new Float64Array(buffer);\n    }\n  }\n  checkMem();\n\n  /** Gets the runtime type info for the given id. */\n  function getInfo(id) {\n    const count = U32[rttiBase >>> 2];\n    if ((id >>>= 0) >= count) throw Error(\"invalid id: \" + id);\n    return U32[(rttiBase + 4 >>> 2) + id * 2];\n  }\n\n  /** Gets the runtime base id for the given id. */\n  function getBase(id) {\n    const count = U32[rttiBase >>> 2];\n    if ((id >>>= 0) >= count) throw Error(\"invalid id: \" + id);\n    return U32[(rttiBase + 4 >>> 2) + id * 2 + 1];\n  }\n\n  /** Gets the runtime alignment of a collection's values or keys. */\n  function getAlign(which, info) {\n    return 31 - Math.clz32((info / which) & 31); // -1 if none\n  }\n\n  /** Allocates a new string in the module's memory and returns its retained pointer. */\n  function __allocString(str) {\n    const length = str.length;\n    const ref = alloc(length << 1, STRING_ID);\n    checkMem();\n    for (let i = 0, j = ref >>> 1; i < length; ++i) U16[j + i] = str.charCodeAt(i);\n    return ref;\n  }\n\n  baseModule.__allocString = __allocString;\n\n  /** Reads a string from the module's memory by its pointer. */\n  function __getString(ref) {\n    checkMem();\n    const id = U32[ref + ID_OFFSET >>> 2];\n    if (id !== STRING_ID) throw Error(\"not a string: \" + ref);\n    return getStringImpl(U32, U16, ref);\n  }\n\n  baseModule.__getString = __getString;\n\n  /** Gets the view matching the specified alignment, signedness and floatness. */\n  function getView(align, signed, float) {\n    if (float) {\n      switch (align) {\n        case 2: return F32;\n        case 3: return F64;\n      }\n    } else {\n      switch (align) {\n        case 0: return signed ? I8 : U8;\n        case 1: return signed ? I16 : U16;\n        case 2: return signed ? I32 : U32;\n        case 3: return signed ? I64 : U64;\n      }\n    }\n    throw Error(\"unsupported align: \" + align);\n  }\n\n  /** Allocates a new array in the module's memory and returns its retained pointer. */\n  function __allocArray(id, values) {\n    const info = getInfo(id);\n    if (!(info & (ARRAYBUFFERVIEW | ARRAY))) throw Error(\"not an array: \" + id + \" @ \" + info);\n    const align = getAlign(VAL_ALIGN, info);\n    const length = values.length;\n    const buf = alloc(length << align, ARRAYBUFFER_ID);\n    const arr = alloc(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id);\n    checkMem();\n    U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = retain(buf);\n    U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf;\n    U32[arr + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = length << align;\n    if (info & ARRAY) U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length;\n    const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);\n    for (let i = 0; i < length; ++i) view[(buf >> align) + i] = values[i];\n    if (info & VAL_MANAGED) for (let i = 0; i < length; ++i) retain(values[i]);\n    return arr;\n  }\n\n  baseModule.__allocArray = __allocArray;\n\n  /** Gets a view on the values of an array in the module's memory. */\n  function __getArrayView(arr) {\n    checkMem();\n    const id = U32[arr + ID_OFFSET >>> 2];\n    const info = getInfo(id);\n    if (!(info & ARRAYBUFFERVIEW)) throw Error(\"not an array: \" + id);\n    const align = getAlign(VAL_ALIGN, info);\n    var buf = U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    const length = info & ARRAY\n      ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2]\n      : U32[buf + SIZE_OFFSET >>> 2] >>> align;\n    return getView(align, info & VAL_SIGNED, info & VAL_FLOAT)\n          .slice(buf >>>= align, buf + length);\n  }\n\n  baseModule.__getArrayView = __getArrayView;\n\n  /** Reads (copies) the values of an array from the module's memory. */\n  function __getArray(arr) {\n    return Array.from(__getArrayView(arr));\n  }\n\n  baseModule.__getArray = __getArray;\n\n  /** Tests whether an object is an instance of the class represented by the specified base id. */\n  function __instanceof(ref, baseId) {\n    var id = U32[(ref + ID_OFFSET) >>> 2];\n    if (id <= U32[rttiBase >>> 2]) {\n      do if (id == baseId) return true;\n      while (id = getBase(id));\n    }\n    return false;\n  }\n\n  baseModule.__instanceof = __instanceof;\n\n  // Pull basic exports to baseModule so code in preInstantiate can use them\n  baseModule.memory = baseModule.memory || memory;\n  baseModule.table = baseModule.table || table;\n\n  // Demangle exports and provide the usual utility on the prototype\n  return demangle(rawExports, Object.defineProperties(baseModule, {\n    I8: { get: function() { checkMem(); return I8; } },\n    U8: { get: function() { checkMem(); return U8; } },\n    I16: { get: function() { checkMem(); return I16; } },\n    U16: { get: function() { checkMem(); return U16; } },\n    I32: { get: function() { checkMem(); return I32; } },\n    U32: { get: function() { checkMem(); return U32; } },\n    I64: { get: function() { checkMem(); return I64; } },\n    U64: { get: function() { checkMem(); return U64; } },\n    F32: { get: function() { checkMem(); return F32; } },\n    F64: { get: function() { checkMem(); return F64; } }\n  }));\n}\n\n/** Wraps a WebAssembly function while also taking care of variable arguments. */\nfunction wrapFunction(fn, setargc) {\n  var wrap = (...args) => {\n    setargc(args.length);\n    return fn(...args);\n  }\n  wrap.original = fn;\n  return wrap;\n}\n\n/** Instantiates an AssemblyScript module using the specified imports. */\nfunction instantiate(module, imports) {\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    new WebAssembly.Instance(module, imports)\n  );\n}\n\nexports.instantiate = instantiate;\n\n/** Instantiates an AssemblyScript module from a buffer using the specified imports. */\nfunction instantiateBuffer(buffer, imports) {\n  return instantiate(new WebAssembly.Module(buffer), imports);\n}\n\nexports.instantiateBuffer = instantiateBuffer;\n\n/** Instantiates an AssemblyScript module from a response using the specified imports. */\nasync function instantiateStreaming(response, imports) {\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    (await WebAssembly.instantiateStreaming(response, imports)).instance\n  );\n}\n\nexports.instantiateStreaming = instantiateStreaming;\n\n/** Demangles an AssemblyScript module's exports to a friendly object structure. */\nfunction demangle(exports, baseModule) {\n  var module = baseModule ? Object.create(baseModule) : {};\n  var setargc = exports[\"__setargc\"] || function() {};\n  function hasOwnProperty(elem, prop) {\n    return Object.prototype.hasOwnProperty.call(elem, prop);\n  }\n  for (let internalName in exports) {\n    if (!hasOwnProperty(exports, internalName)) continue;\n    let elem = exports[internalName];\n    let parts = internalName.split(\".\");\n    let curr = module;\n    while (parts.length > 1) {\n      let part = parts.shift();\n      if (!hasOwnProperty(curr, part)) curr[part] = {};\n      curr = curr[part];\n    }\n    let name = parts[0];\n    let hash = name.indexOf(\"#\");\n    if (hash >= 0) {\n      let className = name.substring(0, hash);\n      let classElem = curr[className];\n      if (typeof classElem === \"undefined\" || !classElem.prototype) {\n        let ctor = function(...args) {\n          return ctor.wrap(ctor.prototype.constructor(0, ...args));\n        };\n        ctor.prototype = {\n          valueOf: function valueOf() {\n            return this[THIS];\n          }\n        };\n        ctor.wrap = function(thisValue) {\n          return Object.create(ctor.prototype, { [THIS]: { value: thisValue, writable: false } });\n        };\n        if (classElem) Object.getOwnPropertyNames(classElem).forEach(name =>\n          Object.defineProperty(ctor, name, Object.getOwnPropertyDescriptor(classElem, name))\n        );\n        curr[className] = ctor;\n      }\n      name = name.substring(hash + 1);\n      curr = curr[className].prototype;\n      if (/^(get|set):/.test(name)) {\n        if (!hasOwnProperty(curr, name = name.substring(4))) {\n          let getter = exports[internalName.replace(\"set:\", \"get:\")];\n          let setter = exports[internalName.replace(\"get:\", \"set:\")];\n          Object.defineProperty(curr, name, {\n            get: function() { return getter(this[THIS]); },\n            set: function(value) { setter(this[THIS], value); },\n            enumerable: true\n          });\n        }\n      } else {\n        if (name === 'constructor') {\n          curr[name] = wrapFunction(elem, setargc);\n        } else { // for methods\n          Object.defineProperty(curr, name, {\n            value: function (...args) {\n              setargc(args.length);\n              return elem(this[THIS], ...args);\n            }\n          });\n        }\n      }\n    } else {\n      if (/^(get|set):/.test(name)) {\n        if (!hasOwnProperty(curr, name = name.substring(4))) {\n          Object.defineProperty(curr, name, {\n            get: exports[internalName.replace(\"set:\", \"get:\")],\n            set: exports[internalName.replace(\"get:\", \"set:\")],\n            enumerable: true\n          });\n        }\n      } else if (typeof elem === \"function\") {\n        curr[name] = wrapFunction(elem, setargc);\n      } else {\n        curr[name] = elem;\n      }\n    }\n  }\n\n  return module;\n}\n\nexports.demangle = demangle;\n","/** URL to the wasm module */\nconst WASM_MODULE_URL = '/wasm/optimized.wasm';\n\nexport default WASM_MODULE_URL;\n","/** class for handling visual output */\n\nexport default class Canvas {\n    private element: HTMLCanvasElement;\n    /** context for drawing */\n    private ctx: CanvasRenderingContext2D;\n\n    constructor(canvasId: string) {\n        this.element = document.getElementById(canvasId) as HTMLCanvasElement;\n        const context = this.element.getContext('2d');\n        if (!context) {\n            throw 'Error: Could not obtain canvas context!';\n        }\n        this.ctx = context;\n    }\n\n    public clearRect(x: number, y: number, width: number, height: number) {\n        this.ctx.clearRect(x, y, width, height);\n    }\n\n    public drawCircle(\n        x: number,\n        y: number,\n        radius: number,\n        rgbFill: string\n    ): void {\n        this.ctx.beginPath();\n        this.ctx.arc(x, y, radius, 0, Math.PI * 2);\n        this.ctx.fillStyle = rgbFill;\n        this.ctx.fill();\n        this.ctx.closePath();\n    }\n\n    public drawRect(\n        x: number,\n        y: number,\n        width: number,\n        height: number,\n        rgbFill: string\n    ) {\n        this.ctx.beginPath();\n        this.ctx.rect(x, y, width, height);\n        this.ctx.fillStyle = rgbFill;\n        this.ctx.fill();\n        this.ctx.closePath();\n    }\n\n    public clearCanvas(): void {\n        this.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n    }\n\n    public get canvasWidth(): number {\n        return this.element.width;\n    }\n\n    public get canvasHeight(): number {\n        return this.element.height;\n    }\n}","/** possible statuses of the game */\nenum BreakOutGameStatuses {\n    NewGame,\n    NotStarted,\n    GameOver\n}\n\nexport default BreakOutGameStatuses","import { instantiateBuffer } from \"assemblyscript/lib/loader\";\n\nimport { ImportedWasmModule, BreakoutGame } from './models/imported-wasm-module.model';\nimport WASM_MODULE_URL from './constants/wasm-url.constant';\nimport Canvas from './models/canvas.model';\nimport BreakOutGameStatuses from './wasm-shared/enums/game-statuses.enum';\n\nlet wasmModuleInstance: ImportedWasmModule;\nlet wasmBreakout: BreakoutGame;\nconst canvasId = 'canvas';\nconst canvas = new Canvas(canvasId);\n\nconst imports: any = {\n    console: {\n        logMessage(msg: number): void {\n            const message = wasmModuleInstance.__getString(msg);\n            console.log(message);\n        }\n    },\n    game: {\n        canContinueCheck(status: BreakOutGameStatuses): void {\n            if (status !== BreakOutGameStatuses.GameOver) {\n                requestAnimationFrame(() => wasmBreakout.gameLoop());\n            }\n        }\n    },\n    canvas: {\n        clearRect(x: number, y: number, width: number, height: number): void {\n            canvas.clearRect(x, y, width, height);\n        },\n        drawCircle(\n            x: number,\n            y: number,\n            radius: number,\n            red: number,\n            green: number,\n            blue: number\n        ): void {\n            const rgb = `rgb(${red}, ${green}, ${blue})`\n            canvas.drawCircle(x, y, radius, rgb);\n        },\n\n        drawRect(\n            x: number,\n            y: number,\n            width: number,\n            height: number,\n            red: number,\n            green: number,\n            blue: number\n        ): void {\n            const rgb = `rgb(${red}, ${green}, ${blue})`;\n            canvas.drawRect(x, y, width, height, rgb);\n        }\n    }\n};\n\nfunction startGame(): void {\n    wasmBreakout.newGameStatus = BreakOutGameStatuses.NewGame;\n    requestAnimationFrame(() => wasmBreakout.gameLoop());\n}\n\nfunction pauseGame(): void {\n    wasmBreakout.newGameStatus = BreakOutGameStatuses.GameOver;\n    \n}\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    console.log('dom content loaded');\n\n    document.getElementById('start-game')!.addEventListener('click', startGame);\n    document.getElementById('pause-game')!.addEventListener('click', pauseGame);\n\n});\n\nfetch(WASM_MODULE_URL)\n    .then(response => response.arrayBuffer())\n    .then(bytes => instantiateBuffer(bytes as Uint8Array, imports))\n    .then(bytes => {\n        wasmModuleInstance = <unknown>bytes as ImportedWasmModule;\n\n        wasmBreakout = new wasmModuleInstance.BreakoutGame(canvas.canvasWidth, canvas.canvasHeight);\n        requestAnimationFrame(() => wasmBreakout.gameLoop());\n\n    });\n\n"]}